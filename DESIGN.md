A “design document” for your project in the form of a Markdown file called DESIGN.md that discusses, technically, how you implemented your project and why you made the design decisions you did. Your design document should be at least several paragraphs in length. Whereas your documentation is meant to be a user’s manual, consider your design document your opportunity to give the staff a technical tour of your project underneath its hood.

Musicboxd is a web application that allows users to manage their music preferences by interacting with the Spotify API. It integrates functionalities such as logging in, searching for songs, reviewing them, and managing user-specific data (such as liked songs and reviews) stored in a SQLite database. The primary aim of this project is to provide a personalized experience for users while allowing them to interact with Spotify's vast music database.

We used Flask, a lightweight Python web framework, to handle HTTP requests and rendering of HTML templates. We chose to use Flask because we're more familiar with the syntax and structure and for its simplicity and flexibility, enabling quick development and easy integration with external libraries like Spotipy. For data storage, we used SQLite for its familiarity and simplicity. The application also uses Flask-Session for session management--sessions are stored on the server's filesystem, and  cookies are used to maintain user state between requests. This allows users to log in, stay authenticated, and retain their session data as they navigate the app. Finally, Spotify API integration is handled using the Spotipy library, which simplifies making requests to the Spotify Web API. It provides methods to search for tracks, fetch detailed information about them, and interact with Spotify's music database.

SQL: There are four tables stored in songs.db that hold the user's data: users, songs, likes, and reviews. Users holds every user's id (which serves as the primary key), username, and password hash generated via werkzeug.security. Songs holds every song's id, title, and artist associated. Reviews holds the review id, the content of the review, timestamp, and the rating. It also references the user id from users and the song id from songs to associate the review with the person who made it and the song it was written about. Likes has a similar structure where the timestamp of the like is recorded and the user id and song id are referenced. Throughout app.py, an extensive variety of queries are executed, such as fetching (for example, to retrieve a user row matching the given username in /login), inserting (such as a new user with a username and hashed password into the users table in /register), updating (like an existing review's text, rating, and timestamp based on the review ID in /edit_review/<int: review_id>), and deleting data (such as a review based on its ID in /delete_review/<int:review_id>). Query results are passed to Flask templates for rendering, such as in /profile where the name, reviews, and liked songs of the user can be displayed and rendered. Paramaterized queries are used with "?" as placeholders to protect against injection attacks. Complex JOIN queries are used to query across multiple tables, as well as filtering and ordering, such as in /all_reviews.

User authentication includes a few different paths. Registration (/register) allows users to sign up by providing a username, password, and confirmation password. Passwords are hashed using werkzeug.security to securely store them, and the user credentials are stored in a database. Error messages are returned as a popup if the username is already in use, the password and confirmation don't match, or any of the 3 fields aren't filled out. We chose to use a popup instead of a completely new error response page in order to make the process as seamless as possible. If the user instead wants to sign into an existing account, they can use the login path. Through login (/login), users can log in with the username and password they created. If the credentials are correct, they are redirected to their profile page. If there is a user already logged in, they can use the logout path (/logout), which clears the session and redirects to the home page.

Once a user is logged in, there is a navbar (created using Bootstrap) at the top of the page that allows for easy access of all the webpages. This navbar is present on all of the webpages, so the user will always be able to access any of the pages or log out. The profile page (/profile) displays user details and their reviews, including the songs they've liked (from the likes table) and the songs they've reviewed (from the reviews table). This page acts as a summary of the user's reviews and activity on the website, which is why it shows only the most recent likes and reviews (with the option to see the full list included as a clickable link). The user is identified at the top of the page by their username, which adds a personal touch and indicates a successful sign in.

In order to start logging songs, the user should go to the song search page (/search) by clicking on it in the navbar. This page allows users to search for songs on Spotify based on a song name and artist. The search is performed via the Spotify API, and the results are stored in the songs table in the SQLite database. We gave the user the option of searching by song title, artist, or both, but in order to prevent an excessively long search return, only the top 10 matching results are displayed. This means that in some instances, searching with both criteria is required to access the desired song, but in others, it may be sufficient to only search by title or by artist. The search functionality utilizes the Spotify API to fetch data about songs based on user input. The Spotipy library makes it easy to interact with the API, allowing the application to search for songs by name or artist and display matching results to the user. Once the user has identified the song in the search result that they would like to review, we gave them the option of viewing the song on Spotify and the option to write their review.

Following the link to write the review brings the user to the song details (/song/<song_id>), since it provides details of a specific song in addition to a review section where users can submit their own reviews and ratings. We display the song title, artist, and album, in case the user would like to know, and there is an embedded Spotify player that allows the user to listen to the song without leaving the website. Users are able to identify their favorite songs through the "like" feature--liked songs are added to their own database, and there is also a webpage dedicated to showing all the songs the user liked. On the song details page, the song's liked status is checked, and users can toggle this (i.e., "like" or "unlike" the song). The like_song() function checks whether the song is already liked and toggles its status accordingly, which allows for songs to be removed from the liked list if the user unlikes them.

Users can submit a review for a song directly on the song details page. The review is saved in the reviews table, and users are able to provide a rating (via a 5-star input for intuitive use). Reviews are displayed under the song details, and users can read others' reviews and contribute their own. The page also calculates and displays the average rating for the song based on all user reviews. Back on the profile page, users can edit and delete their existing reviews.


All Liked Songs (/all_liked):

Displays a list of all songs liked by the user.
All Reviews (/all_reviews):

Displays all reviews submitted by the user.
Review Management (/edit_review, /delete_review):

Users can edit and delete their reviews for songs.

LINK TO PUBLIC GITHUB REPOSITORY (file size was too large for Gradescope): https://github.com/sufjanfan/Music-Letterboxd

LINK TO VIDEO: https://youtu.be/Wk4C4LI0LYA

Musicboxd is a web application that allows users to manage their music preferences by interacting with the Spotify API. It integrates functionalities such as logging in, searching for songs, reviewing them, and managing user-specific data (such as liked songs and reviews) stored in a SQLite database. The primary aim of this project is to provide a personalized experience for users while allowing them to interact with Spotify's vast music database.

We used Flask, a lightweight Python web framework, to handle HTTP requests and rendering of HTML templates. We chose to use Flask because we're more familiar with the syntax and structure and for its simplicity and flexibility, enabling quick development and easy integration with external libraries like Spotipy. For data storage, we used SQLite for its familiarity and simplicity. The application also uses Flask-Session for session management--sessions are stored on the server's filesystem, and  cookies are used to maintain user state between requests. This allows users to log in, stay authenticated, and retain their session data as they navigate the app. Finally, Spotify API integration is handled using the Spotipy library, which simplifies making requests to the Spotify Web API. It provides methods to search for tracks, fetch detailed information about them, and interact with Spotify's music database. We used Bootstrap for styling and layout, ensuring that the interface is responsive and visually appealing. The navbar is consistently displayed across all pages, providing easy navigation for the user to access any part of the application. Interactive elements like the review form and "like" buttons are made as intuitive as possible, providing feedback to the user when an action is taken (for example, toggling a heart to "like" or "unlike" a song).

SQL: There are four tables stored in songs.db that hold the user's data: users, songs, likes, and reviews. Users holds every user's id (which serves as the primary key), username, and password hash generated via werkzeug.security. Songs holds every song's id, title, and artist associated. Reviews holds the review id, the content of the review, timestamp, and the rating. It also references the user id from users and the song id from songs to associate the review with the person who made it and the song it was written about. Likes has a similar structure where the timestamp of the like is recorded and the user id and song id are referenced. Throughout app.py, an extensive variety of queries are executed, such as fetching (for example, to retrieve a user row matching the given username in /login), inserting (such as a new user with a username and hashed password into the users table in /register), updating (like an existing review's text, rating, and timestamp based on the review ID in /edit_review/<int: review_id>), and deleting data (such as a review based on its ID in /delete_review/<int:review_id>). Query results are passed to Flask templates for rendering, such as in /profile where the name, reviews, and liked songs of the user can be displayed and rendered. Paramaterized queries are used with "?" as placeholders to protect against injection attacks. Complex JOIN queries are used to query across multiple tables, as well as filtering and ordering, such as in /all_reviews.

User authentication includes a few different paths. Registration (/register) allows users to sign up by providing a username, password, and confirmation password. Passwords are hashed using werkzeug.security to securely store them, and the user credentials are stored in a database. Error messages are returned as a popup if the username is already in use, the password and confirmation don't match, or any of the 3 fields aren't filled out. We chose to use a popup instead of a completely new error response page in order to make the process as seamless as possible. If the user instead wants to sign into an existing account, they can use the login path. Through login (/login), users can log in with the username and password they created. If the credentials are correct, they are redirected to their profile page. If there is a user already logged in, they can use the logout path (/logout), which clears the session and redirects to the home page.

Once a user is logged in, the profile page (/profile) displays user details and their reviews, including the songs they've liked (from the likes table) and the songs they've reviewed (from the reviews table). This page acts as a summary of the user's reviews and activity on the website, which is why it shows only the most recent likes and reviews (with the option to see the full list included as a clickable link that directs the user to either the "Your Liked Songs" page or the "Your Reviews" page, depending on the button they choose). The user is identified at the top of the page by their username, which adds a personal touch and indicates a successful sign in.

In order to start logging songs, the user should go to the song search page (/search) by clicking on it in the navbar. This page allows users to search for songs on Spotify based on a song name and artist. The search is performed via the Spotify API, and the results are stored in the songs table in the SQLite database. We gave the user the option of searching by song title, artist, or both, but in order to prevent an excessively long search return, only the top 10 matching results are displayed. This means that in some instances, searching with both criteria is required to access the desired song, but in others, it may be sufficient to only search by title or by artist. The search functionality utilizes the Spotify API to fetch data about songs based on user input. The Spotipy library makes it easy to interact with the API, allowing the application to search for songs by name or artist and display matching results to the user. Once the user has identified the song in the search result that they would like to review, we gave them the option of viewing the song on Spotify and the option to write their review.

Following the link to write the review brings the user to the song details (/song/<song_id>), since it provides details of a specific song in addition to a review section where users can submit their own reviews and ratings. We display the song title, artist, and album, in case the user would like to know, and there is an embedded Spotify player that allows the user to listen to the song without leaving the website. Users are able to identify their favorite songs through the "like" feature--liked songs are added to their own database, and there is also a webpage dedicated to showing all the songs the user liked. On the song details page, the song's liked status is checked, and users can toggle this (i.e., "like" or "unlike" the song). The like_song() function checks whether the song is already liked and toggles its status accordingly, which allows for songs to be removed from the liked list if the user unlikes them.

Users can submit a review for a song directly on the song details page. The review is saved in the reviews table, and users are able to provide a rating (via a 5-star input for intuitive use). Reviews are displayed under the song details, and users can read others' reviews and contribute their own. The page also calculates and displays the average rating for the song based on all user reviews. Back on the profile page (or on the "Your Reviews" page for a complete list), users can edit and delete their existing reviews. When the edit form is submitted, the review in the database is updated with the new content and rating, and the timestamp is refreshed. A validation check ensures that the user is only allowed to edit their own reviews. Users can also press a button to delete their reviews--upon deletion, the review is removed from the database, and the page is updated accordingly. The "Community Reviews" and "Your Liked Songs" pages provide compilations of data, with the former displaying all reviews from all users (with more recent reviews appearing first) and the latter displaying all songs the user has liked. Throughout the website, reviews are displayed on individual cards within a grid to make the information easier to read and more visually appealing.
